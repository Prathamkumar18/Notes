#TypeScript:
-Datatypes: string,number,any(avoid),boolean,enum,array,tuples
-Operators: type,union,intersection
-Functions: optional param, req. param, rest param.
-Class,Interfaces,access modifiers

#Angular Setup:
-create project: ng new projectName --no-strict --standalone false --routing false
-to set up external css styles: add to angular.json in styles. (eg. adding bootstrap)
-assets: to store images or ext. files. and then also add path in angular.json
-create component: ng g c comp_name
-create module: ng g m mod_name
-create services: ng g s serv_name
-create pipe: ng g p pipe_name
-to build: ng build
-every components,services,pipes,module needs to be mentioned in app.module.ts in @ngModule
-every components have: .html, .css, .ts, .spec.ts(test file)

#Angular Basics:
-Passing Data:
  -String interpolation: {{var_name}}
  -Property Binding: [property_name] (use this to bind property to same html or other comp. html)
  -Event Binding: (event_name) (use this to listen the event generated by other comp. (use    (event_fun)=fun($event) to get the data.)
  -Two way binding= [(event_name)] to listen event and for property binding.
  -[ngModel] and [(ngModel)] will bind the view with model and bind event with the model resp.
  -cross component data transfer: use @Input() property; to receive the data and @Output() property=new EventEmitter<Property_type>(); to emit data.

-Directives:
 -Structural directive:
   -ngIf - *ngIf="condition; else template_name" or use @if(condition)
   -elseIf - use @else if(condition)
   -else - use @else{} or use <ng-template #template_name> ... </ng-template>
   -ngFor - *ngFor="let x of array; let i=index"
   -ngSwitch- <div [ngSwitch]="value">
                       <li *ngSwitchCase="val1">...</li>
                                   :
                       <li *ngSwitchDefault>default</li>
                  </div>
 -Attribute directive:
   -ngStyle - [ngStyle]="{'color':'blue'}" 
   -ngClass - [ngClass]="{class-name : condition}"

-LifeCycle hooks: self explanatory
   -ngOnInit(){}
   -ngOnDestroy(){}
   -ngOnChanges(){}

-Dependency Injection:
  - constructor(private name : ClassName){} 

#Angular Components:
  @Component({
     selector: 'app-component',      -> this can be used as <app-component><app-component> to embed this component.
     templateUrl: 'path.html',         -> html file path
     styleUrl: 'path.css'                    ->css file path
  })
  export class ComponentName{}

#Angular Services:
  - write all the business logic here and use dependency injection to use in other class.
  - use @Injectable() for injecting services into services.
  - Add service class in providers:[] in app.module.ts  OR  use @Injectable({providedIn: 'root'})export class MyService { ... }

#Angular Observables:
  - Emit: event_name=new EventEmitter<Event_type>(); or event_name=new Subject<Event_type>();
  - Listen: event_name.subscribe((data:dataType)=>{ logic}); or event_name.next((data:dataType)=>{ logic });

#Angular Pipes:
  - add pipe class to declarations[] in app.module.ts
  - built-in pipes: (uppercase, date etc.) in the html use | operator to transform data. eg.<p>{{name | uppercase:limit}}</p>
  - custom pipes:  use ng g p pipe_name to create pipe.
         @Pipe({name:'pipe_name'})
         export class PipeName implements PipeTransform{
           transform(value: any, limit:number) {
                      ...
           }
        }

#Angular Routing:
- create a routing file (app-routing.module.ts) to handle all the routings and then add Routing class name in the imports[] in app.module.ts

       const appRoutes:Routes=[
         {path:'',redirectTo:'/path',pathMatch:'full'},
         {path:'recipe',component:RecipeComponent,children:[
            {path:':id/edit',component:RecipeEditComponent},
          ]},
         {path:'**',component:ErrorPageComponent}
       ];
      @NgModule({
        imports:[RouterModule.forRoot(appRoutes)],
        exports:[RouterModule]
       })
       export class AppRoutingModule{}

- In html use routerLink="path" or [routerLink]="['path','...']"
- In html use routerLinkActive="active" to mark the element active.
- Inject (private router:Router,private routes:ActivatedRoute)

- To add router programmatically: use (click)=fun() and then navigation in function.
      - use this.router.navigate(['path'],[...] ,{relativeTo:this.routes,queryParams:{a:'',b:''},fragment:'#hello'}) where 2nd parameter is optional.
      -In 2nd parameter- relativeTo uses activatedRoute (current route)  , queryParams for passing query as k-v pair and fragments.

- To access the data passed in the url: [use activated route]
    - Let say the url is: http:localhost:4200/home/1?filter=country#location ( basepath/param/path_param?query_param(k-v)#fragment )
    - We can get data in two ways: using snapshot (static data) and using observables subscribe (dynamic data)
    -  Using snapshot:
        this.id = this.routes.snapshot.paramMap.get('id');
        this.filter = this.routes.snapshot.queryParamMap.get('filter');
        this.fragment = this.routes.snapshot.fragment;

    - Using Observables:
        this.routes.paramMap.subscribe(params => {
           this.id = params.get('id');
        });
        this.routes.queryParamMap.subscribe(params => {
            this.filter = params.get('filter');
        });
        this.routes.fragment.subscribe(fragment => {
            this.fragment = fragment;
        });

#Angular Forms:
- Types: Template Driven Approach and Reactive Forms
- Template Driven:
  - add FormsModule in imports[]
  - <form (ngSubmit)="onSubmit()" #f="ngForm">...</form> 
     - to access the form data in ts file:   @ViewChild('f') form:NgForm; and now we can use form.value.field_name to get data.
  - to reset form: this.form.reset();
  - Set: to set the whole form.
    this.form.form.setValue({
       userData:{                                html: for creating model group and to access it in ts use (this.form.value.userData.name)
         'name':'prats',                            <div ngModelGroup="userData">
         'email':'a@gmail.com'                    <input type="text" id="username" class="form-control" name="username" ngModel required>
       },                                                      <input type="email" id="email" class="form-control" name="email" ngModel required email #email="ngModel">
       gender:'male'                               </div>
      });
  - Patch: to set few field(s).
    this.form.form.patchValue({
       userData:{
          'name':'prats'
        }
     }
  - validations: eg. <input type="email" name="email" ngModel required email #email="ngModel">
     here, required and email are validations , #email is for local reference.
  - use only ngModel for getting the data, [ngModel]=".." for default option and [(ngModel)]=".." for real time changes.
  - local-reference: these can be used for getting more insight of the field
      - #email="ngModel"  - element level
      - #userData="ngModelGroup" - element group level
      - #f="ngForm" - form level
      And now we can use these as: email.valid , email.touched etc.

- Reactive Form:
  - add ReactiveFormsModule in imports[]
  - <form  [formGroup]="form" (ngSubmit)="onSubmit()">
     - to access the form data in ts file: we have to define the whole schema of the form.
         form: FormGroup;    and then we can use this.form.get('userData.username')
         ngOnInit(){
            this.form= new FormGroup({
                 userData: new FormGroup({
                    username: new FormControl(null, [Validators.required,this.customValidation.bind(this)]),   1st param- default value, 2nd param - array of validators(inbuilt as well as custom)
                    email: new FormControl(null, [Validators.required, Validators.email]),
                 }),
                 gender: new FormControl('male'),
            });
  - to reset form: this.form.reset();
  - set and patch works same as that of template driven approach.
  - validators: Built-in and custom both should be written while initializing the form. and custom validator is just a simple method(control:FormControl){return {string:boolean}}
     and use this.customValidatorName.bind(this) in the validators array.
  - to sync ts with the html code use suitable form names in every field like formGroupName, formControlName.
  - no need to explicitly define local ref. instead use formName.get('field_name') and use prop. like valid, touched etc.

#Angular Http:
- Add HttpClientModule in the app.module.ts and inject HttpClient to use the http methods.
- this.http.get<DataType>('url',{
         {
             headers: new HttpHeaders({'custom-header':'Hello'}),
             params: {'id', '1},
             responseType: 'text',
             observe: 'response | body | events'
   })
   .subscribe((resData)=>{});
- this.http.put<DataType>('url',data).subscribe((resData)=>{});
- this.http.post<DataType>('url',data).subscribe((resData)=>{});
- this.http.delete<DataType>('url').subscribe((resData)=>{});

- Interceptors: It is for modifying the req. or res.
  - Add below in the providers array in app.module.ts
  {
      provide: HTTP_INTERCEPTORS,
      useClass: Interceptor_class_name,
      multi: true,
   }
  - @Injectable()
     export class AuthInterceptorService implements HttpInterceptor {  
          intercept(req: HttpRequest<any>, next: HttpHandler) {
                 console.log('req. on its way');
                 const modifiedReq=req.clone({headers: req.headers.append('auth', 'xyz')});
                 return next.handle(modifiedReq);
           }
      }


#AngularAuthentication:
- Refer recipe project - app/auth folder.

#AngularModules: set of components.
- define module class for each feature.
- remove components from app.module.ts and place it in the resp. feature module.
- export the module components and import the module class in app.module.ts

#AngularSignals:
- to change the ui when the value changes.
- Angular does it automatically by internally using the change detection which leads to performance   issue and large bundle.
- Hence to avoid it use signals to update the ui when value changes.
- signals provide 2 functions: update and set.
- update: counter.update((oldVal)=> oldVal + 1);
- set: counter.set(5);
- Eg.
  Normal:                          Signals:
  couter=0;                    counter=signal(0);
  f(){ counter++;}         f(){ counter.update((oldVal)=> oldVal+1);
  {{counter}}-html       {{counter()}} -html
- Computer Signals: is used to derive value from other signals.
  - const doubleCount = computed(() => counter() * 2);
- effect()- used to notify when signals changes. (generally in ngOnInit or constructor)
  - effect(() => {
       console.log(`The current count is: ${count()}`);
    });

  
